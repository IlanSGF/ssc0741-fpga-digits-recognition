
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module pcihello(

	//////////// CLOCK //////////
	CLOCK_50, 	// BANK 4
	CLOCK2_50, 	// BANK 7
	CLOCK3_50, 	// BANK 3A

	//////////// LED (High Active) //////////
	LEDG,
	LEDR,

	//////////// KEY (Active Low) //////////
	KEY,

	// switches
   SW,
	
	//////////// SEG7 (Low Active) //////////
	HEX0,
	HEX1,
	HEX2,
	HEX3,
	HEX4,
	HEX5,
	HEX6,
	HEX7,

	//////////// PCIe //////////
	PCIE_PERST_N,
	PCIE_REFCLK_P,
	PCIE_RX_P,
	PCIE_TX_P,
	PCIE_WAKE_N,

	//////////// Fan Control //////////
	FAN_CTRL 
);

//=======================================================
//  PARAMETER declarations
//=======================================================


//=======================================================
//  PORT declarations
//=======================================================

//////////// CLOCK //////////
input 		          		CLOCK_50;
input 		          		CLOCK2_50;
input 		          		CLOCK3_50;

//////////// LED (High Active) //////////
output		     [8:0]		LEDG;
output		    [17:0]		LEDR;

//////////// KEY (Active Low) //////////
input 		     [3:0]		KEY;
input            [17:0]	   SW;

//////////// SEG7 (Low Active) //////////
output		     [6:0]		HEX0;
output		     [6:0]		HEX1;
output		     [6:0]		HEX2;
output		     [6:0]		HEX3;
output		     [6:0]		HEX4;
output		     [6:0]		HEX5;
output		     [6:0]		HEX6;
output		     [6:0]		HEX7;

//////////// PCIe //////////
input 		          		PCIE_PERST_N;
input 		          		PCIE_REFCLK_P;
input 		     [1:0]		PCIE_RX_P;
output		     [1:0]		PCIE_TX_P;
output		          		PCIE_WAKE_N;

//////////// Fan Control //////////
inout 		          		FAN_CTRL;


//=======================================================
//  REG/WIRE declarations
//=======================================================

parameter SIZE = 5;
parameter KERNEL = 3;

wire [31:0] outbus;
wire [31:0] inbus;

wire clk_boy;
wire [31:0] tmp;
wire [31:0] pxl_out;
wire valid;
reg [31:0] img[27:0][27:0];
reg [31:0] outBuf = 32'b0;
reg [31:0] inBuf  = 32'b0;

//TEST
wire [9:0] count;

integer pixelx = -1;
integer pixely = -1;
integer send_receive = 0;

wire [31:0] reg_00; wire [31:0] reg_01; wire [31:0] reg_02;
wire [31:0] reg_10; wire [31:0] reg_11; wire [31:0] reg_12;
wire [31:0] reg_20; wire [31:0] reg_21; wire [31:0] reg_22;


integer i;
integer j;
initial begin
    for (i=0; i<=27; i=i+1)
      for (j=0; j<=27; j=j+1)
          img[i][j] = 32'b0;
end

//=======================================================
//  Structural coding
//=======================================================

    pcihellocore u0 (
        .pcie_hard_ip_0_rx_in_rx_datain_0       (PCIE_RX_P[0]),       //     pcie_hard_ip_0_rx_in.rx_datain_0
        .pcie_hard_ip_0_tx_out_tx_dataout_0     (PCIE_TX_P[0]),     //    pcie_hard_ip_0_tx_out.tx_dataout_0
        .pcie_hard_ip_0_powerdown_pll_powerdown (PCIE_WAKE_N), // pcie_hard_ip_0_powerdown.pll_powerdown
        .pcie_hard_ip_0_powerdown_gxb_powerdown (PCIE_WAKE_N), //                         .gxb_powerdown
        .pcie_hard_ip_0_refclk_export           (PCIE_REFCLK_P),           //    pcie_hard_ip_0_refclk.export
        .pcie_hard_ip_0_pcie_rstn_export        (PCIE_PERST_N),
        .hexport_external_connection_export     (inbus),     	// hexport_external_connection.export
        .inport_external_connection_export      (outbus)       //  inport_external_connection.export
    );

	 
	 conv c0 (
		.clk (clk_boy),
		.reset (SW[0]),
		.pxl_in (inBuf[15:0]),
		.reg_00 (reg_00), .reg_01 (reg_01), .reg_02 (reg_02),
		.reg_10 (reg_10), .reg_11 (reg_11), .reg_12 (reg_12),
		.reg_20 (reg_20), .reg_21 (reg_21), .reg_22 (reg_22),
		.pxl_out (pxl_out),
		.count (count),
		.valid (valid)
	);
	 
	//////////// FAN Control //////////
//assign FAN_CTRL = 1'b0; // turn off FAN

assign clk_boy = inbus[31];
assign tmp = inbus[31:0];

always@(posedge clk_boy) begin
	// salva valor no buffer de entrada (que eh enviado
	// para o modulo de convolucao)
	inBuf[31:0] = inbus[31:0];

	if (valid == 1) begin
		//outBuf[30:0] = (~pxl_out[30:0]) + 1;
		outBuf[31:0] = pxl_out[31:0];
		//outBuf[31] = 0;
	end else begin
		outBuf[31:0] = 32'b1;
	end

/*
	// reset da matriz de convolucao e da contagem
	if (SW[0] == 1) begin
		send_receive = 0;
		pixelx = 0;
		pixely = 0;
	end
	
	// leitura dos pixels e chamada da convolucao
	else begin
		if (send_receive == 0) begin
			
		end
	end
	
	else begin
		if (send_receive == 0) begin
		// esquecer primeiro lixo de sincronizacao
			img[pixelx][pixely][31:0] = inbus[31:0];
			
			pixely = pixely + 1;
		
			//TEST
			count = count + 1;	
		
			if (pixely >= SIZE) begin
			//if (pixelx >= 1) begin
				//CHAMAR CONVOLUCAO			
				pixely = 0;	
				pixelx = pixelx + 1;
				
				if (pixelx >= SIZE) begin
					pixelx = 0;	
					send_receive = 1;			
				end			
			end		
		end else begin
			outBuf[31:0] = img[pixelx][pixely][31:0];		
			pixely = pixely + 1;
		
			//TEST
			count = count + 1;	
			
			if (pixely >= SIZE) begin
			//if (pixelx >= 1) begin					
				pixely = 0;	
				pixelx = pixelx + 1;
				
				if (pixelx >= SIZE) begin
					pixely = 0;
					pixelx = 0;	
					send_receive = 0;			
				end	
			end
		end
	end
*/
/*
	if (send_receive == 0) begin
		img[pixelx][pixely][31:0] = inbus[31:0];		
		send_receive = 1;
		count = count + 1; SIZE*SIZE
		
		
	end else begin
		outBuf[31:0] = img[pixelx][pixely][31:0];
		send_receive = 0;
		count = count + 1;
	end
*/	
/*	if (send_receive == 0) begin
		
		// se nao for o primeiro lixo de sincronizacao
		if (pixelx >= 0) begin
			img[pixelx][pixely][31:0] = inbus[31:0];
			pixely = pixely + 1;
		
			//TEST
			count = count + 1;	
		
			if (pixely >= 2) begin
			//if (pixelx >= 1) begin
				//CHAMAR CONVOLUCAO			
				pixely = 0;	
				pixelx = pixelx + 1;
				
				if (pixelx >= 2) begin
					pixelx = 0;	
					send_receive = 1;			
				end			
			end
		
		end else begin
			pixelx = 0;
			pixely = 0;
		end
		
	end else begin
		outBuf[31:0] = img[pixelx][pixely][31:0];		
		pixely = pixely + 1;
	
		//TEST
		count = count + 1;	
		
		if (pixely >= 2) begin
		//if (pixelx >= 1) begin					
			pixely = 0;	
			pixelx = pixelx + 1;
			
			if (pixelx >= 2) begin
				pixely = -1;
				pixelx = -1;	
				send_receive = 0;			
			end	
		end
	end
*/
end

assign outbus[31:0] = outBuf[31:0];
assign HEX4 = count;
assign HEX5 = send_receive;

assign LEDG[7] = valid;
assign LEDG[6:0] = count[6:0];

assign LEDR[17] = SW[0];
assign LEDR[16] = ~valid;

assign LEDR[15:8] = ~inBuf[7:0];
assign LEDR[7:0] = {~inBuf[31], ~inBuf[6:0]};


assign HEX7 = inBuf[7:0];
assign HEX6 = inBuf[15:8];

//assign HEX7 = pixelx[7:0];
//assign HEX6 = pixely[7:0];
//assign HEX0 = img[pixelx][pixely][7:0];
//assign HEX1 = img[pixelx][pixely][15:8];
//assign HEX2 = img[pixelx][pixely][23:16];
//assign HEX3 = img[pixelx][pixely][31:24];
assign HEX0 = outBuf[7:0];
assign HEX1 = outBuf[15:8];
assign HEX2 = outBuf[23:16];
assign HEX3 = outBuf[31:24];

endmodule
